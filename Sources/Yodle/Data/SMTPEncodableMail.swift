//
//  SMTPEncodableMail.swift
//  
//
//  Created by Linus Bohle on 24.05.22.
//

import Foundation

// https://datatracker.ietf.org/doc/html/rfc5322
// https://datatracker.ietf.org/doc/html/rfc5321
// https://datatracker.ietf.org/doc/html/rfc822

/// Main protocol to which all mail-data entities of Yodle conform. This protocol guarantees the basic
/// SMTP headers to be set correctly and ensures that additional (custom) headers do not conflict
/// with the standardized ones.
public protocol SMTPEncodableMail: Identifiable {
    var id: UUID { get }

    var sender: MailUser { get }
    var recipients: Set<MailUser> { get }

    // https://serverfault.com/questions/554520/smtp-allows-for-multiple-from-addresses-in-the-rfc-was-this-ever-useful-why-do
    var from: Set<MailUser>? { get set }
    var cc: Set<MailUser>? { get set }
    var bcc: Set<MailUser>? { get set }
    var replyTo: Set<MailUser>? { get set }

    var subject: String? { get set }

    /// Any additional headers that should be associated with the Mail object.
    var additionalSMTPHeaders: [SMTPHeader] { get set }

    /// Encodes a mail object's body properties for transport via SMTP.
    /// - Returns: A string representing the mail body data
    func encodeMailData() -> String
}

extension SMTPEncodableMail {
    /// A combination of the standardized default headers (generated by the mail object's properties) and additionally set headers. Standardized headers
    /// take precedence over additionally set ones.
    var combinedHeaders: [SMTPHeader] {
        var headers: [SMTPHeader] = []

        headers.append(SMTPHeader(header: "Message-Id", value: "\(id.uuidString)@localhost"))
        headers.append(SMTPHeader(header: "Date", value: Date().smtpFormattedDate))

        if let from = from {
            headers.append(SMTPHeader(header: "From", value: from.compactMap{ $0.smtpFormatted }.joined(separator: ",")))
        } else {
            headers.append(SMTPHeader(header: "From", value: sender.smtpFormatted))
        }

        headers.append(SMTPHeader(header: "To", value: recipients.compactMap{ $0.smtpFormatted }.joined(separator: ",")))

        if let cc = cc {
            headers.append(SMTPHeader(header: "Cc", value: cc.compactMap{ $0.smtpFormatted }.joined(separator: ",")))
        }

        if let bcc = bcc {
            headers.append(SMTPHeader(header: "Bcc", value: bcc.compactMap{ $0.smtpFormatted }.joined(separator: ",")))
        }

        if let replyTo = replyTo {
            headers.append(SMTPHeader(header: "Reply-To", value: replyTo.compactMap{ $0.smtpFormatted }.joined(separator: ",")))
        }

        if let subject = subject {
            headers.append(SMTPHeader(header: "Subject", value: subject))
        }

        // only add custom header if it does not conflict with standardized ones above
        for additionalHeader in additionalSMTPHeaders {
            if !headers.contains(where: { $0.header == additionalHeader.header }) {
                headers.append(additionalHeader)
            }
        }

        return headers
    }
}

/// Stores data of an SMTP header.
public struct SMTPHeader {
    var header: String
    var value: String
}

/// Represents a typical SMTP mail user.
public struct MailUser: Hashable {
    let name: String?
    let email: String

    var smtpFormatted: String {
        if let name = name {
            return "\(name) <\(email)>"
        } else {
            return email
        }
    }
}
